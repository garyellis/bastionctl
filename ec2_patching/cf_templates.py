from troposphere import Template
from troposphere import GetAtt
from troposphere import Ref
from troposphere import Join
from troposphere import Output
from ec2_patching import cf_resources
import logging



# this can be genericised and placed into cf_resources module
def sg_ingress_allow_bastion_ip(bastion_ip, sg_ids):
    """
    Troposphere sg ingress rules helper
    """
    rules = []
    for i, sg_id in enumerate(sg_ids):
        rules.append(
            cf_resources.security_group_ingress(
                name='AllowBastion{}'.format(i),
                desc='Allow bastion (linux patching)',
                ip_protocol='tcp',
                from_port=22,
                to_port=22,
                group_id=sg_id,
                cidr=bastion_ip
            )
        )
    return rules

def ec2_instance_outputs(name, instance):
    """
    """
    outputs = []
    outputs.append(Output(
        "{}PublicIp".format(name),
        Description="Bastion public Ip address",
        Value=GetAtt(instance, 'PublicIp')
    ))
    outputs.append(Output(
        "{}PrivateIp".format(name),
        Description="Bastion private Ip address",
        Value=GetAtt(instance, 'PrivateIp')
    ))
    return outputs


def create_bastion_template(name, ami_id, instance_type, key_name, subnet_id, vpc_id, bastion_sg_ingress, sg_ids):
    """
    Returns the  bastion cloudformation template
    """
#    logger.debug('creating bastion template')
    t = Template()
    t.add_description('Generated by infiniti ec2-patching cli')

    # setup our bastion security group and ec2 instance
    bastion_sg = cf_resources.security_group(
      name=name,
      desc=name,
      vpc_id=vpc_id
    )

    bastion_sg_ingress = cf_resources.security_group_ingress(
      name=name,
      desc=name,
      ip_protocol='tcp',
      from_port=22,
      to_port=22,
      group_id=Ref(bastion_sg),
      cidr=bastion_sg_ingress
    )

    bastion_sg_egress_tcp_name = '{}-tcp-all'.format(name)
    bastion_sg_egress_tcp = cf_resources.security_group_egress(
      name=bastion_sg_egress_tcp_name,
      desc=bastion_sg_egress_tcp_name,
      ip_protocol='tcp',
      from_port='0',
      to_port='65535',
      group_id=Ref(bastion_sg),
      cidr='0.0.0.0/0'
    )

    bastion_sg_egress_udp_name = '{}-udp-all'.format(name)
    bastion_sg_egress_udp = cf_resources.security_group_egress(
      name=bastion_sg_egress_udp_name,
      desc=bastion_sg_egress_udp_name,
      ip_protocol='udp',
      from_port='0',
      to_port='65535',
      group_id=Ref(bastion_sg),
      cidr='0.0.0.0/0'
    )   

    bastion_instance = cf_resources.ec2_instance(
      name=name,
      ami_id=ami_id,
      keyname=key_name,
      instance_type=instance_type,
      sg_ids=[Ref(bastion_sg)],
      subnet_id=subnet_id
    )

    # allow sg ingress on to the bastion ip
    sg_ingress_bastion_ip = sg_ingress_allow_bastion_ip(
        bastion_ip=Join("", [GetAtt(bastion_instance, 'PrivateIp'), "/32"]),
        sg_ids=sg_ids
    )

    cf_resources.add_template_resources(
        template=t,
        resources=[
            bastion_sg,
            bastion_sg_ingress,
            bastion_sg_egress_tcp,
            bastion_sg_egress_udp,
            bastion_instance,
            sg_ingress_bastion_ip,
        ]
    )

    # setup the bastion instance outputs
    bastion_instance_outputs = ec2_instance_outputs('bastion', bastion_instance)

    cf_resources.add_template_outputs(
        template=t,
        outputs=[
            bastion_instance_outputs
        ]
    )

    return t.to_yaml()
